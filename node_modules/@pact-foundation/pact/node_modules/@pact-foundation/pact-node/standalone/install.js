"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var request = require("request");
var pact_standalone_1 = require("../src/pact-standalone");
var path = require("path");
var fs = require("fs");
var decompress = require("decompress");
var tar = require("tar");
var chalk = require("chalk");
var rimraf = require("rimraf");
function download(data) {
    return new Promise(function (resolve, reject) {
        if (fs.existsSync(path.resolve(data.filepath))) {
            console.log(chalk.yellow("Binary already downloaded, skipping..."));
            return resolve(data);
        }
        console.log(chalk.yellow("Downloading Pact Standalone Binary v" + pact_standalone_1.PACT_STANDALONE_VERSION + " for platform " + data.platform + " from " + data.url));
        var len = 0;
        var downloaded = 0;
        var time = Date.now();
        request(data.url)
            .on("response", function (res) { return len = parseInt(res.headers["content-length"], 10); })
            .on("data", function (chunk) {
            downloaded += chunk.length;
            var now = Date.now();
            if (now - time > 1000) {
                time = now;
                console.log(chalk.gray("Downloaded " + (100 * downloaded / len).toFixed(2) + "%..."));
            }
        })
            .pipe(fs.createWriteStream(data.filepath))
            .on("finish", function () {
            console.log(chalk.green("Finished downloading binary to " + data.filepath));
            resolve(data);
        })
            .on("error", function (e) { return reject("Error downloading binary from " + data.url + ": " + e); });
    });
}
function extract(data) {
    if (fs.existsSync(data.platformFolderPath)) {
        return Promise.resolve();
    }
    fs.mkdirSync(data.platformFolderPath);
    console.log(chalk.yellow("Extracting binary from " + data.filepath + "."));
    return (data.isWindows ?
        decompress(data.filepath, data.platformFolderPath, { strip: 1 }) :
        tar.x({
            file: data.filepath,
            strip: 1,
            cwd: data.platformFolderPath,
            Z: true
        }))
        .then(function () {
        rimraf.sync(path.resolve(__dirname, "bin", "pact-publish" + (data.isWindows ? ".bat" : "")));
        console.log(chalk.green("Extraction done."));
    })
        .catch(function (e) { return Promise.reject("Extraction failed for " + data.filepath + ": " + e); });
}
function setup(platform, arch) {
    platform = platform || process.platform;
    arch = arch || process.arch;
    var binary = "pact-" + pact_standalone_1.PACT_STANDALONE_VERSION + "-";
    switch (platform) {
        case "win32":
            binary += "win32.zip";
            break;
        case "darwin":
            binary += "osx.tar.gz";
            break;
        case "linux":
            binary += "linux-x86" + (arch === "x64" ? "_64" : "") + ".tar.gz";
            break;
    }
    console.log(chalk.gray("Installing Pact Standalone Binary for " + platform + "."));
    return Promise.resolve({
        url: "https://github.com/pact-foundation/pact-ruby-standalone/releases/download/v" + pact_standalone_1.PACT_STANDALONE_VERSION + "/" + binary,
        filepath: path.resolve(__dirname, binary),
        platform: platform,
        arch: arch,
        isWindows: "win32" === platform,
        platformFolderPath: path.resolve(__dirname, pact_standalone_1.getPlatformFolderName(platform, arch))
    });
}
exports.default = (function (platform, arch) {
    return setup(platform, arch)
        .then(function (d) { return download(d); })
        .then(function (d) { return extract(d); })
        .then(function () { return console.log(chalk.green("Pact Standalone Binary is ready.")); })
        .catch(function (e) { return console.log(chalk.red("Postinstalled Failed Unexpectedly: " + e)); });
});
//# sourceMappingURL=install.js.map